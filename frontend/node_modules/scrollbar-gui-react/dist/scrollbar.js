"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ScrollbarGUI = void 0;
var _react = require("react");
require("./scrollbar.css");
var _jsxRuntime = require("react/jsx-runtime");
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
var TRACK_PADDING = 10;
var ScrollbarGUI = exports.ScrollbarGUI = function ScrollbarGUI(_ref) {
  var children = _ref.children;
  var scrollRef = (0, _react.useRef)(null);
  var thumbYRef = (0, _react.useRef)(null);
  var thumbXRef = (0, _react.useRef)(null);
  var _useState = (0, _react.useState)(false),
    _useState2 = _slicedToArray(_useState, 2),
    showY = _useState2[0],
    setShowY = _useState2[1];
  var _useState3 = (0, _react.useState)(false),
    _useState4 = _slicedToArray(_useState3, 2),
    showX = _useState4[0],
    setShowX = _useState4[1];
  var _useState5 = (0, _react.useState)(20),
    _useState6 = _slicedToArray(_useState5, 2),
    thumbYHeight = _useState6[0],
    setThumbYHeight = _useState6[1];
  var _useState7 = (0, _react.useState)(20),
    _useState8 = _slicedToArray(_useState7, 2),
    thumbXWidth = _useState8[0],
    setThumbXWidth = _useState8[1];
  var isDraggingY = (0, _react.useRef)(false);
  var isDraggingX = (0, _react.useRef)(false);
  var startY = (0, _react.useRef)(0);
  var startX = (0, _react.useRef)(0);
  var startScrollTop = (0, _react.useRef)(0);
  var startScrollLeft = (0, _react.useRef)(0);
  var updateThumbs = function updateThumbs() {
    var el = scrollRef.current;
    if (!el) return;
    var showVertical = el.scrollHeight > el.clientHeight;
    var showHorizontal = el.scrollWidth > el.clientWidth;
    setShowY(showVertical);
    setShowX(showHorizontal);
    if (showVertical) {
      var ratio = el.clientHeight / el.scrollHeight;
      var availableHeight = el.clientHeight - TRACK_PADDING;
      setThumbYHeight(Math.max(30, ratio * availableHeight));
    }
    if (showHorizontal) {
      var _ratio = el.clientWidth / el.scrollWidth;
      var availableWidth = el.clientWidth - TRACK_PADDING;
      setThumbXWidth(Math.max(30, _ratio * availableWidth));
    }
    updateThumbPosition();
  };
  var updateThumbPosition = function updateThumbPosition() {
    var el = scrollRef.current;
    var thumbY = thumbYRef.current;
    var thumbX = thumbXRef.current;
    if (!el) return;
    if (showY && thumbY) {
      var thumbHeight = thumbY.offsetHeight;
      var maxTrack = el.clientHeight - TRACK_PADDING - thumbHeight;
      var scrollRatio = el.scrollTop / (el.scrollHeight - el.clientHeight);
      var top = scrollRatio * maxTrack;
      thumbY.style.transform = "translateY(".concat(top, "px)");
    }
    if (showX && thumbX) {
      var thumbWidth = thumbX.offsetWidth;
      var _maxTrack = el.clientWidth - TRACK_PADDING - thumbWidth;
      var _scrollRatio = el.scrollLeft / (el.scrollWidth - el.clientWidth);
      var left = _scrollRatio * _maxTrack;
      thumbX.style.transform = "translateX(".concat(left, "px)");
    }
  };
  var onThumbYMouseDown = function onThumbYMouseDown(e) {
    e.preventDefault();
    isDraggingY.current = true;
    startY.current = e.clientY;
    startScrollTop.current = scrollRef.current.scrollTop;
    thumbYRef.current.classList.add('dragging');
    var onMouseMove = function onMouseMove(e) {
      if (!isDraggingY.current || isDraggingX.current) return;
      var el = scrollRef.current;
      var deltaY = e.clientY - startY.current;
      var maxThumbTop = el.clientHeight - TRACK_PADDING - thumbYRef.current.offsetHeight;
      var scrollableHeight = el.scrollHeight - el.clientHeight;
      var scrollRatio = scrollableHeight / maxThumbTop;
      el.scrollTop = startScrollTop.current + deltaY * scrollRatio;
      updateThumbPosition();
    };
    var _onMouseUp = function onMouseUp() {
      isDraggingY.current = false;
      thumbYRef.current.classList.remove('dragging');
      window.removeEventListener('mousemove', onMouseMove);
      window.removeEventListener('mouseup', _onMouseUp);
    };
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', _onMouseUp);
  };
  var onThumbXMouseDown = function onThumbXMouseDown(e) {
    e.preventDefault();
    isDraggingX.current = true;
    startX.current = e.clientX;
    startScrollLeft.current = scrollRef.current.scrollLeft;
    thumbXRef.current.classList.add('dragging');
    var onMouseMove = function onMouseMove(e) {
      if (!isDraggingX.current || isDraggingY.current) return;
      var el = scrollRef.current;
      var deltaX = e.clientX - startX.current;
      var maxThumbLeft = el.clientWidth - TRACK_PADDING - thumbXRef.current.offsetWidth;
      var scrollableWidth = el.scrollWidth - el.clientWidth;
      var scrollRatio = scrollableWidth / maxThumbLeft;
      el.scrollLeft = startScrollLeft.current + deltaX * scrollRatio;
      updateThumbPosition();
    };
    var _onMouseUp2 = function onMouseUp() {
      isDraggingX.current = false;
      thumbXRef.current.classList.remove('dragging');
      window.removeEventListener('mousemove', onMouseMove);
      window.removeEventListener('mouseup', _onMouseUp2);
    };
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', _onMouseUp2);
  };
  (0, _react.useEffect)(function () {
    var el = scrollRef.current;
    if (!el) return;
    var observer = new ResizeObserver(updateThumbs);
    observer.observe(el);
    if (el.firstElementChild) observer.observe(el.firstElementChild);
    updateThumbs();
    var ticking = false;
    var onScroll = function onScroll() {
      if (!ticking) {
        requestAnimationFrame(function () {
          updateThumbPosition();
          ticking = false;
        });
        ticking = true;
      }
    };
    el.addEventListener('scroll', onScroll);
    return function () {
      observer.disconnect();
      el.removeEventListener('scroll', onScroll);
    };
  }, [showY, showX]);
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    className: "scroll-container",
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
      className: "scroll-content",
      ref: scrollRef,
      children: children
    }), showY && /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
      className: "scrollbar-y",
      onClick: function onClick(e) {
        if (isDraggingX.current || isDraggingY.current) return;
        e.stopPropagation();
        var el = scrollRef.current;
        var track = e.currentTarget;
        var trackRect = track.getBoundingClientRect();
        var clickY = e.clientY - trackRect.top;
        var thumbHeight = thumbYRef.current.offsetHeight;
        var maxTrack = track.clientHeight - TRACK_PADDING - thumbHeight;
        var scrollRatio = (clickY - TRACK_PADDING / 2 - thumbHeight / 2) / maxTrack;
        var targetScrollTop = scrollRatio * (el.scrollHeight - el.clientHeight);
        el.scrollTo({
          top: targetScrollTop,
          behavior: 'smooth'
        });
      },
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: "thumb-y",
        ref: thumbYRef,
        style: {
          height: "".concat(thumbYHeight, "px")
        },
        onMouseDown: onThumbYMouseDown
      })
    }), showX && /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
      className: "scrollbar-x",
      onClick: function onClick(e) {
        if (isDraggingX.current || isDraggingY.current) return;
        e.stopPropagation();
        var el = scrollRef.current;
        var track = e.currentTarget;
        var trackRect = track.getBoundingClientRect();
        var clickX = e.clientX - trackRect.left;
        var thumbWidth = thumbXRef.current.offsetWidth;
        var maxTrack = track.clientWidth - TRACK_PADDING - thumbWidth;
        var scrollRatio = (clickX - TRACK_PADDING / 2 - thumbWidth / 2) / maxTrack;
        var targetScrollLeft = scrollRatio * (el.scrollWidth - el.clientWidth);
        el.scrollTo({
          left: targetScrollLeft,
          behavior: 'smooth'
        });
      },
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: "thumb-x",
        ref: thumbXRef,
        style: {
          width: "".concat(thumbXWidth, "px")
        },
        onMouseDown: onThumbXMouseDown
      })
    })]
  });
};